package com.knockturnmc.informous.discord

import com.destroystokyo.paper.exception.ServerSchedulerException
import it.unimi.dsi.fastutil.ints.Int2ObjectArrayMap
import it.unimi.dsi.fastutil.ints.IntArrayList
import org.bukkit.Bukkit

object DuplicateExceptionIdentifier {

    private val recentTaskExceptions = Int2ObjectArrayMap<IntArrayList>()

    /**
     * Compares the hashes of all StackTraceElements up until the call to CraftTask#run to those generated by a previous
     * exception originating from the same BukkitTask.
     *
     * @param exception the exception thrown during the execution of a scheduled task.
     * @return whether the provided exception is a duplicate of a recent task exception.
     */
    fun isDuplicateTaskException(exception: ServerSchedulerException): Boolean {
        val taskId = exception.task.taskId
        val initialException = exception.cause!!
        val hashArray = IntArrayList()

        for (element in initialException.stackTrace) {
            if (element.className.endsWith("CraftTask") && element.methodName.equals("run")) break
            hashArray.add(element.hashCode())
        }

        synchronized(recentTaskExceptions) {
            if (recentTaskExceptions.containsKey(taskId)) {
                val previousHashArray = recentTaskExceptions.get(taskId)!!
                if (hashArray.equals(previousHashArray)) return true
            }

            recentTaskExceptions.put(taskId, hashArray)
            return false
        }
    }

    /**
     * Bukkit does not provide a way to observe when a task is completed/cancelled. This method should be called
     * periodically to clear the recent exception list of any task ids that are no longer active/queued.
     */
    fun cleanUp() {
        val scheduler = Bukkit.getScheduler()

        synchronized(recentTaskExceptions) {
            val iterator = recentTaskExceptions.iterator()

            while(iterator.hasNext()) {
                val taskId = iterator.next().key

                // Remove any task that is no longer active/queued
                if (scheduler.isCurrentlyRunning(taskId) || scheduler.isQueued(taskId)) continue
                else iterator.remove()
            }
        }
    }

}