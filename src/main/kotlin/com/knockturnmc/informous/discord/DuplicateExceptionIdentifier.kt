package com.knockturnmc.informous.discord

import com.destroystokyo.paper.exception.ServerSchedulerException
import com.google.common.base.Objects
import it.unimi.dsi.fastutil.ints.Int2ObjectArrayMap
import it.unimi.dsi.fastutil.ints.IntArrayList
import org.bukkit.Bukkit
import org.bukkit.plugin.Plugin

object DuplicateExceptionIdentifier {

    private val recentTaskExceptions = Int2ObjectArrayMap<CachedTaskException>()

    /**
     * Compares the hashes of all StackTraceElements up until the call to CraftTask#run to those generated by a previous
     * exception originating from the same BukkitTask.
     *
     * @param exception the exception thrown during the execution of a scheduled task.
     * @return whether the provided exception is a duplicate of a recent task exception.
     */
    fun isDuplicateTaskException(exception: ServerSchedulerException): Boolean {
        val initialException = exception.cause!!
        val stacktrace = initialException.stackTrace
        val plugin = exception.responsiblePlugin

        // Duplicate exceptions from the same/similar tasks will share these common factors in the first
        // StackTraceElement of the exception wrapped by ServerSchedulerException.
        val key = with(stacktrace[0]) {
            Objects.hashCode(plugin, this.fileName, this.className, this.methodName, this.lineNumber)
        }

        val hashArray = IntArrayList()

        for (element in stacktrace) {
            if (element.className.endsWith("CraftTask") && element.methodName.equals("run")) break
            hashArray.add(element.hashCode())
        }

        synchronized(recentTaskExceptions) {
            if (recentTaskExceptions.containsKey(key)) {
                val previousException = recentTaskExceptions.get(key)!!
                if (hashArray.equals(previousException.hashArray)) return true
            }

            recentTaskExceptions.put(
                key,
                CachedTaskException(exception.task.taskId, exception.responsiblePlugin, hashArray)
            )

            return false
        }
    }

    /**
     * Bukkit does not provide a way to observe when a task is completed/cancelled. This method should be called
     * periodically to clear the recent exception list of any task ids that are no longer active/queued.
     */
    fun cleanUp() {
        val scheduler = Bukkit.getScheduler()

        synchronized(recentTaskExceptions) {
            val iterator = recentTaskExceptions.iterator()

            while (iterator.hasNext()) {
                val taskId = iterator.next().value.taskId

                // Remove any task that is no longer active/queued
                if (scheduler.isCurrentlyRunning(taskId) || scheduler.isQueued(taskId)) continue
                else iterator.remove()
            }
        }
    }

}

/**
 * Since the task ID cannot be used as the key for the "recentExceptions" map, the task ID must be retained in this
 * data class so that exceptions from inactive tasks may be removed from the cache.
 */
data class CachedTaskException(val taskId: Int, val plugin: Plugin, val hashArray: IntArrayList)